---
sidebar_position: 99
title: "ERC20BurnFacet"
description: "Contract documentation for ERC20BurnFacet"
gitSource: "https://github.com/maxnorm/Compose/blob/326d9e4b8d8f7ef437a77f59f91bb1619c2d1a6c/src/token/ERC20/ERC20/ERC20BurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Contract documentation for ERC20BurnFacet
</DocSubtitle>

<Callout type="info" title="Key Features">
- Supports token burning for both self-owned balances and allowances from other accounts.
- Emits standard ERC-20 &#x60;Transfer&#x60; events to zero address, preserving compatibility with ecosystem monitoring tools.
- Implements diamond storage pattern for efficient and isolated state management.
</Callout>

## Overview

The ERC20BurnFacet provides token burning functionality for ERC-20 compliant diamonds. It allows users to reduce the circulating supply of tokens either from their own balances or by using approved allowances. This facet is designed to integrate seamlessly into the diamond storage pattern, ensuring efficient state management for token data.

---

## Storage

### ERC20Storage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC20Storage {
    mapping(address owner => uint256 balance) balanceOf;
    uint256 totalSupply;
    mapping(address owner => mapping(address spender => uint256 allowance)) allowance;
}`}
</ExpandableCode>

---
### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: ""
    }
  ]}
  showRequired={false}
/>

## Functions

### getStorage

Returns the ERC20 storage struct from the predefined diamond storage slot. Uses inline assembly to set the storage slot reference.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() internal pure returns (ERC20Storage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC20Storage",
      description: "The ERC20 storage struct reference."
    }
  ]}
  showRequired={false}
/>

---
### burn

Burns (destroys) a specific amount of tokens from the caller&#x27;s balance. Emits a Transfer event to the zero address.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _value) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_value",
      type: "uint256",
      description: "The amount of tokens to burn."
    }
  ]}
  showRequired={false}
/>

---
### burnFrom

Burns tokens from another account, deducting from the caller&#x27;s allowance. Emits a Transfer event to the zero address.

<ExpandableCode language="solidity" maxLines={8}>
{`function burnFrom(address _account, uint256 _value) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_account",
      type: "address",
      description: "The address whose tokens will be burned."
    },
    {
      name: "_value",
      type: "uint256",
      description: "The amount of tokens to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when tokens are transferred between two addresses.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 _value);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "Address sending the tokens."
          },
          {
            name: "_to",
            type: "address",
            description: "Address receiving the tokens."
          },
          {
            name: "_value",
            type: "uint256",
            description: "Amount of tokens transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC20InsufficientBalance" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when an account has insufficient balance for a transfer or burn.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InsufficientBalance(address _sender, uint256 _balance, uint256 _needed);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC20InsufficientAllowance" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when a spender tries to use more than the approved allowance.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InsufficientAllowance(address _spender, uint256 _allowance, uint256 _needed);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import { IDiamondCut } from "path/to/diamond/interfaces/IDiamondCut.sol";
import { ERC20BurnFacet } from "path/to/facets/ERC20BurnFacet.sol";

contract ExampleUsage {
    function addERC20BurnFacet(address diamond, address erc20BurnFacet) external {
        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);
        bytes4[] memory functionSelectors = new bytes4[](2);
        functionSelectors[0] = ERC20BurnFacet.burn.selector;
        functionSelectors[1] = ERC20BurnFacet.burnFrom.selector;

        cut[0] = IDiamondCut.FacetCut({
            facetAddress: erc20BurnFacet,
            action: IDiamondCut.FacetCutAction.Add,
            functionSelectors: functionSelectors
        });

        IDiamondCut(diamond).diamondCut(cut, address(0), "");
    }

    function useBurnFunction(address diamond, uint256 amount) external {
        ERC20BurnFacet(diamond).burn(amount);
    }

    function useBurnFromFunction(address diamond, address account, uint256 amount) external {
        ERC20BurnFacet(diamond).burnFrom(account, amount);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure that the facet is added to the diamond using the correct selectors for &#x60;burn&#x60; and &#x60;burnFrom&#x60; functions.
- Validate all state changes through robust testing, as burning affects global balances and allowance tracking.
- Maintain storage layout consistency with the diamond pattern to avoid overwrites during upgrades.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
Restrict access to &#x60;burnFrom&#x60; to ensure that the caller has a sufficient approved allowance from the target account. Prevent reentrancy by marking functions non-reentrant if applicable. Validate inputs to prevent balance underflows and ensure that token amounts are positive values.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC20BurnFacet" />
</div>

<LastUpdated date="2025-12-15T21:47:15.525Z" />
