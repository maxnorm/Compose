---
sidebar_position: 99
title: "ERC20PermitMod"
description: "LibERC20Permit â€” Library for ERC-2612 Permit Logic - Thrown when a permit signature is invalid or expired."
---

import DocHero from '@site/src/components/docs/DocHero';
import Callout from '@site/src/components/ui/Callout';


## Overview

The ERC20PermitMod provides a library for implementing ERC-2612 Permit functionality, enabling off-chain approvals of token transfers through signatures. This improves user experience by allowing gasless approvals and adheres to EIP-712 for secure and structured data hashing and signing.


[View Source](https://github.com/maxnorm/Compose/blob/eabc77b81e461d751a5a8e003c3a9c2e818b9d3c/src/token/ERC20/ERC20Permit/ERC20PermitMod.sol)



<Callout type="info" title="Key Features">
- Implements ERC-2612 Permit functionality for gasless approvals\n- Ensures signature security using the DOMAIN_SEPARATOR\n- Compatible with the Compose diamond proxy system
</Callout>



<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>


## Storage


Storage position: `ERC20_STORAGE_POSITION` - Used for diamond storage pattern.



### State Variables


#### ERC20_STORAGE_POSITION



#### STORAGE_POSITION







## Functions


### DOMAIN_SEPARATOR


Returns the domain separator used in the encoding of the signature for &#123;permit&#125;. This value is unique to a contract and chain ID combination to prevent replay attacks. **Returns**



```solidity
function DOMAIN_SEPARATOR() view returns (bytes32);
```




**Returns**

| Name | Type | Description |
|------|------|-------------|

| `-` | `bytes32` | The domain separator. |




### getERC20Storage



```solidity
function getERC20Storage() pure returns (ERC20Storage storage s);
```





### getPermitStorage



```solidity
function getPermitStorage() pure returns (ERC20PermitStorage storage s);
```





### permit


Validates a permit signature and sets allowance. Emits Approval event; must be emitted by the calling facet/contract. **Parameters**



```solidity
function permit(address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s) ;
```



**Parameters**

| Name | Type | Description |
|------|------|-------------|

| `_owner` | `address` | Token owner. |

| `_spender` | `address` | Token spender. |

| `_value` | `uint256` | Allowance value. |

| `_deadline` | `uint256` | Permit's time deadline. |







## Events


### Approval


Emitted when an approval is made for a spender by an owner. **Parameters**



```solidity
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
```



| Parameter | Type | Description |
|-----------|------|-------------|

| `_owner` | `address` | The address granting the allowance. |

| `_spender` | `address` | The address receiving the allowance. |

| `_value` | `uint256` | The amount approved. |






## Errors


### ERC20InvalidSpender


Thrown when the spender address is invalid (e.g., zero address). **Parameters**



```solidity
error ERC20InvalidSpender(address _spender);
```



### ERC2612InvalidSignature


Thrown when a permit signature is invalid or expired. **Parameters**



```solidity
error ERC2612InvalidSignature(
address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s
);
```





## Structs


### ERC20PermitStorage


**Note:** storage-location: erc8042:compose.erc20.permit



```solidity
struct ERC20PermitStorage {
mapping(address owner =&gt; uint256) nonces;
}
```



### ERC20Storage


**Note:** storage-location: erc8042:compose.erc20



```solidity
struct ERC20Storage {
mapping(address owner =&gt; uint256 balance) balanceOf;
uint256 totalSupply;
mapping(address owner =&gt; mapping(address spender =&gt; uint256 allowance)) allowance;
uint8 decimals;
string name;
}
```





## Usage Example

```solidity
pragma solidity ^0.8.0;\n\nimport { LibERC20Permit } from &quot;path/to/LibERC20Permit.sol&quot;;\n\ncontract MyTokenFacet {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(&quot;diamond.storage.token&quot;);\n\n    function usePermit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        LibERC20Permit.permit(_owner, _spender, _value, _deadline, _v, _r, _s);\n        emit PermitUsed(_owner, _spender, _value);\n    }\n\n    event PermitUsed(address indexed owner, address indexed spender, uint256 value);\n}
```



## Best Practices

<Callout type="tip" title="Best Practice">
- Use the permit function to minimize the need for user gas expenses by validating off-chain signatures and setting allowances.\n- Store and retrieve necessary values like DOMAIN_SEPARATOR consistently using the diamond storage pattern.\n- Ensure emitted Approval events reflect the changes specified by the permit signature for clarity and reproducibility.
</Callout>





## Integration Notes

<Callout type="success" title="Shared Storage">
LibERC20Permit adheres to the diamond storage pattern, ensuring storage variables like DOMAIN_SEPARATOR and allowances remain consistent and centralized. Any changes made via this library will be reflected across all facets sharing and accessing the same diamond storage.
</Callout>




