---
sidebar_position: 99
title: "ERC20BridgeableMod"
description: "LibERC20Bridgeable — ERC-7802 Library - Revert when a provided receiver is invalid(e.g,zero address) ."
gitSource: "https://github.com/maxnorm/Compose/blob/35c4fb10b73eff0850482e188d0f1eca595cff2c/src/token/ERC20/ERC20Bridgeable/ERC20BridgeableMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
LibERC20Bridgeable — ERC-7802 Library - Revert when a provided receiver is invalid(e.g,zero address) .
</DocSubtitle>

<Callout type="info" title="Key Features">
- Enforces &#x60;trusted-bridge&#x60; role for cross-chain minting and burning.
- Provides robust validation through &#x60;checkTokenBridge&#x60;.
- Aligns with the diamond storage pattern to ensure safe and predictable storage management.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

ERC20BridgeableMod provides essential functionality for cross-chain operations within a diamond-based architecture. It ensures only trusted bridges can trigger mint and burn operations, maintaining security and composability. The module enforces storage safety and aligns with the diamond proxy pattern through explicit access control and storage management.

---

## Storage

### AccessControlStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct AccessControlStorage {
mapping(address account => mapping(bytes32 role => bool hasRole)) hasRole;
}`}
</ExpandableCode>

---
### ERC20Storage

ERC-8042 compliant storage struct for ERC20 token data. **Note:** storage-location: erc8042:compose.erc20

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC20Storage {
mapping(address owner => uint256 balance) balanceOf;
uint256 totalSupply;
}`}
</ExpandableCode>

Storage position: &#x60;ERC20_STORAGE_POSITION&#x60; - Used for diamond storage pattern.
---
### State Variables

<PropertyTable
  properties={[
    {
      name: "ERC20_STORAGE_POSITION",
      type: "bytes32",
      description: " (Value: `keccak256(&quot;compose.erc20&quot;)`)"
    },
    {
      name: "ACCESS_STORAGE_POSITION",
      type: "bytes32",
      description: " (Value: `keccak256(&quot;compose.accesscontrol&quot;)`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### checkTokenBridge

Internal check to check if the bridge (caller) is trusted. Reverts if caller is zero or not in the AccessControl &#x60;trusted-bridge&#x60; role. **Parameters**

<ExpandableCode language="solidity" maxLines={8}>
{`function checkTokenBridge(address _caller) view;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_caller",
      type: "address",
      description: "The address to validate"
    }
  ]}
  showRequired={false}
/>

---
### crosschainBurn

Cross-chain burn — callable only by an address having the &#x60;trusted-bridge&#x60; role. **Parameters**

<ExpandableCode language="solidity" maxLines={8}>
{`function crosschainBurn(address _from, uint256 _value) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The account to burn tokens from."
    },
    {
      name: "_value",
      type: "uint256",
      description: "The amount to burn."
    }
  ]}
  showRequired={false}
/>

---
### crosschainMint

Cross-chain mint — callable only by an address having the &#x60;trusted-bridge&#x60; role. **Parameters**

<ExpandableCode language="solidity" maxLines={8}>
{`function crosschainMint(address _account, uint256 _value) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_account",
      type: "address",
      description: "The account to mint tokens to."
    },
    {
      name: "_value",
      type: "uint256",
      description: "The amount to mint."
    }
  ]}
  showRequired={false}
/>

---
### getAccessControlStorage

helper to return AccessControlStorage at its diamond slot

<ExpandableCode language="solidity" maxLines={8}>
{`function getAccessControlStorage() pure returns (AccessControlStorage storage s);`}
</ExpandableCode>

---
### getERC20Storage

Returns the ERC20 storage struct from the predefined diamond storage slot. Uses inline assembly to set the storage slot reference. **Returns**

<ExpandableCode language="solidity" maxLines={8}>
{`function getERC20Storage() pure returns (ERC20Storage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC20Storage",
      description: "The ERC20 storage struct reference."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="CrosschainBurn" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when a crosschain transfer burns tokens. **Parameters**
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event CrosschainBurn(address indexed _from, uint256 _amount, address indexed _sender);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "Address of the account tokens are being burned from."
          },
          {
            name: "_amount",
            type: "uint256",
            description: "Amount of tokens burned."
          },
          {
            name: "_sender",
            type: "address",
            description: "Address of the caller (msg.sender) who invoked crosschainBurn."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
  <Accordion title="CrosschainMint" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when tokens are minted via a cross-chain bridge. **Parameters**
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event CrosschainMint(address indexed _to, uint256 _amount, address indexed _sender);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_to",
            type: "address",
            description: "The recipient of minted tokens."
          },
          {
            name: "_amount",
            type: "uint256",
            description: "The amount minted."
          },
          {
            name: "_sender",
            type: "address",
            description: "The bridge account that triggered the mint (msg.sender)."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when tokens are transferred between two addresses. **Parameters**
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 _value);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "Address sending the tokens."
          },
          {
            name: "_to",
            type: "address",
            description: "Address receiving the tokens."
          },
          {
            name: "_value",
            type: "uint256",
            description: "Amount of tokens transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="AccessControlUnauthorizedAccount" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the account does not have a specific role. **Parameters**
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error AccessControlUnauthorizedAccount(address _account, bytes32 _role);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC20InsufficientBalance" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InsufficientBalance(address _from, uint256 _accountBalance, uint256 _value);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC20InvalidBridgeAccount" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Revert when caller is not a trusted bridge. **Parameters**
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InvalidBridgeAccount(address _caller);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC20InvalidCallerAddress" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Revert when caller address is invalid. **Parameters**
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InvalidCallerAddress(address _caller);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC20InvalidReciever" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      /// @dev Uses ERC-8042 for storage location standardization and ERC-6093 for error conventions Revert when a provided receiver is invalid(e.g,zero address) . **Parameters**
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InvalidReciever(address _receiver);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC20InvalidSender" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the sender address is invalid (e.g., zero address). **Parameters**
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InvalidSender(address _sender);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

contract ERC20BridgeableFacet {

    function burnTokens(address _account, uint256 _amount) external {
        LibERC20Bridgeable.crosschainBurn(_account, _amount);
    }

    function mintTokens(address _account, uint256 _amount) external {
        LibERC20Bridgeable.crosschainMint(_account, _amount);
    }

    function isBridgeTrusted(address _bridge) external view returns (bool) {
        try LibERC20Bridgeable.checkTokenBridge(_bridge) {
            return true;
        } catch {
            return false;
        }
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure that only addresses with the &#x60;trusted-bridge&#x60; role call &#x60;crosschainBurn&#x60; and &#x60;crosschainMint&#x60;.
- Use &#x60;checkTokenBridge&#x60; to validate bridge access before executing cross-chain operations.
- Avoid modifying storage slots directly; rely on &#x60;getAccessControlStorage&#x60; and &#x60;getERC20Storage&#x60; for consistent and safe access.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
ERC20BridgeableMod interacts with diamond storage using predefined slots for both access control and ERC20 storage. Functions like &#x60;getAccessControlStorage&#x60; and &#x60;getERC20Storage&#x60; ensure that storage remains consistent and accessible across facets. Implementing facets must not alter these slots or their layout to preserve functionality. Access control validation is tightly integrated and must align with the diamond&#x27;s role management.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC20BridgeableMod" />
</div>

<LastUpdated date="2025-12-17T00:38:30.368Z" />
