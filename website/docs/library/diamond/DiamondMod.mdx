---
sidebar_position: 1
title: "DiamondMod"
description: "Manages diamond facets and internal proxy logic."
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/diamond/DiamondMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Manages diamond facets and internal proxy logic.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Manages the mapping of function selectors to facet addresses.
- Facilitates dynamic function dispatch via `diamondFallback`.
- Enforces deployment-time constraints for facet additions.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

The DiamondMod provides core functionality for managing facets within a Compose diamond. It handles the addition of facets and their associated function selectors, ensuring proper registration. This module is crucial for the diamond's ability to delegate calls to the correct facet implementations.

---

## Storage

### FacetCutAction

Add=0, Replace=1, Remove=2

---
### DiamondStorage

storage-location: erc8042:compose.diamond

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct DiamondStorage {
    mapping(bytes4 functionSelector => FacetAndPosition) facetAndPosition;
    /**
    * \`selectors\` contains all function selectors that can be called in the diamond.
    */
    bytes4[] selectors;
}`}
</ExpandableCode>

---
### FacetAndPosition

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetAndPosition {
    address facet;
    uint32 position;
}`}
</ExpandableCode>

---
### FacetCut

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetCut {
    address facetAddress;
    FacetCutAction action;
    bytes4[] functionSelectors;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "DIAMOND_STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.diamond\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### addFacets

Adds facets and their function selectors to the diamond. Only supports adding functions during diamond deployment.

<ExpandableCode language="solidity" maxLines={8}>
{`function addFacets(FacetCut[] memory _facets) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_facets",
      type: "FacetCut[]",
      description: ""
    }
  ]}
  showRequired={false}
/>

---
### diamondFallback

Find facet for function that is called and execute the function if a facet is found and return any value.

<ExpandableCode language="solidity" maxLines={8}>
{`function diamondFallback() ;`}
</ExpandableCode>

---
### getStorage

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() pure returns (DiamondStorage storage s);`}
</ExpandableCode>

## Events

<AccordionGroup>
  <Accordion title="DiamondCut" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);`}
      </ExpandableCode>
    </div>

  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="CannotAddFunctionToDiamondThatAlreadyExists" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="FunctionNotFound" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error FunctionNotFound(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="InvalidActionWhenDeployingDiamond" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error InvalidActionWhenDeployingDiamond(address facetAddress, FacetCutAction action, bytes4[] functionSelectors);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="NoBytecodeAtAddress" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error NoBytecodeAtAddress(address _contractAddress, string _message);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IDiamondMod} from "@compose/contracts/diamond/interfaces/IDiamondMod.sol";

contract MyFacet {
    IDiamondMod public diamondMod;

    constructor(address _diamondMod) {
        diamondMod = IDiamondMod(_diamondMod);
    }

    function someFacetFunction() external {
        // Example of calling a function that might be handled by diamondFallback
        // This is illustrative; direct calls to diamondFallback are less common
        // as the proxy handles dispatch automatically.
        // diamondMod.diamondFallback(...);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Facet additions are restricted to the initial diamond deployment phase to maintain upgrade safety.
- Utilize custom errors for explicit error handling during facet registration and function dispatch.
- Ensure facet function selectors are unique to prevent ambiguous dispatch.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
DiamondMod interacts directly with the diamond's storage to maintain the mapping of function selectors to facet addresses. The `addFacets` function is designed to be called only during the initial deployment of the diamond. `diamondFallback` is the internal dispatch mechanism, invoked by the diamond proxy to find and execute the appropriate facet function based on the incoming call's selector.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <RelatedDocs
    items={[
      {
        title: "DiamondCutMod",
        href: "/docs/library/diamond/DiamondCutMod",
        description: "Related module in diamond",
        icon: "ðŸ“¦"
      }
    ]}
  />
</div>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="DiamondMod" />
</div>

<LastUpdated date="2025-12-30T14:36:41.499Z" />
