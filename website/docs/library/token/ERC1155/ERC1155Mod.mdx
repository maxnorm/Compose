---
sidebar_position: 1
title: "ERC1155Mod"
description: "Manage and transfer ERC-1155 multi-token standards"
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/token/ERC1155/ERC1155Mod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Manage and transfer ERC-1155 multi-token standards
</DocSubtitle>

<Callout type="info" title="Key Features">
- Supports minting and burning of individual ERC-1155 tokens and batches.
- Implements safe transfer logic, ensuring receiver contracts implement `onERC1155Received` or `onERC1155BatchReceived`.
- Allows setting a base URI and token-specific URIs for metadata retrieval.
- Emits standard ERC-1155 `TransferSingle` and `TransferBatch` events.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

This module provides the core logic for ERC-1155 multi-token management. It enables minting, burning, and safe transfers of multiple token types. By composing this module, diamonds can offer robust multi-token functionalities while adhering to EIP-1155 standards and ensuring receiver safety.

---

## Storage

### ERC1155Storage

ERC-8042 compliant storage struct for ERC-1155 token data. storage-location: erc8042:compose.erc1155

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC1155Storage {
    mapping(uint256 id => mapping(address account => uint256 balance)) balanceOf;
    mapping(address account => mapping(address operator => bool)) isApprovedForAll;
    string uri;
    string baseURI;
    mapping(uint256 tokenId => string) tokenURIs;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.erc1155\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### burn

Burns a single token type from an address. Decreases the balance and emits a TransferSingle event. Reverts if the account has insufficient balance.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(address _from, uint256 _id, uint256 _value) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The address whose tokens will be burned."
    },
    {
      name: "_id",
      type: "uint256",
      description: "The token type to burn."
    },
    {
      name: "_value",
      type: "uint256",
      description: "The amount of tokens to burn."
    }
  ]}
  showRequired={false}
/>

---
### burnBatch

Burns multiple token types from an address in a single transaction. Decreases balances for each token type and emits a TransferBatch event. Reverts if the account has insufficient balance for any token type.

<ExpandableCode language="solidity" maxLines={8}>
{`function burnBatch(address _from, uint256[] memory _ids, uint256[] memory _values) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The address whose tokens will be burned."
    },
    {
      name: "_ids",
      type: "uint256[]",
      description: "The token types to burn."
    },
    {
      name: "_values",
      type: "uint256[]",
      description: "The amounts of tokens to burn for each type."
    }
  ]}
  showRequired={false}
/>

---
### getStorage

Returns the ERC-1155 storage struct from the predefined diamond storage slot. Uses inline assembly to set the storage slot reference.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() pure returns (ERC1155Storage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC1155Storage",
      description: "The ERC-1155 storage struct reference."
    }
  ]}
  showRequired={false}
/>

---
### mint

Mints a single token type to an address. Increases the balance and emits a TransferSingle event. Performs receiver validation if recipient is a contract.

<ExpandableCode language="solidity" maxLines={8}>
{`function mint(address _to, uint256 _id, uint256 _value, bytes memory _data) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_to",
      type: "address",
      description: "The address that will receive the tokens."
    },
    {
      name: "_id",
      type: "uint256",
      description: "The token type to mint."
    },
    {
      name: "_value",
      type: "uint256",
      description: "The amount of tokens to mint."
    }
  ]}
  showRequired={false}
/>

---
### mintBatch

Mints multiple token types to an address in a single transaction. Increases balances for each token type and emits a TransferBatch event. Performs receiver validation if recipient is a contract.

<ExpandableCode language="solidity" maxLines={8}>
{`function mintBatch(address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_to",
      type: "address",
      description: "The address that will receive the tokens."
    },
    {
      name: "_ids",
      type: "uint256[]",
      description: "The token types to mint."
    },
    {
      name: "_values",
      type: "uint256[]",
      description: "The amounts of tokens to mint for each type."
    }
  ]}
  showRequired={false}
/>

---
### safeBatchTransferFrom

Safely transfers multiple token types from one address to another in a single transaction. Validates ownership, approval, and receiver address before updating balances for each token type. Performs ERC1155Receiver validation if recipient is a contract (safe transfer). Complies with EIP-1155 safe transfer requirements.

<ExpandableCode language="solidity" maxLines={8}>
{`function safeBatchTransferFrom(
address _from,
address _to,
uint256[] memory _ids,
uint256[] memory _values,
address _operator
) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The address to transfer from."
    },
    {
      name: "_to",
      type: "address",
      description: "The address to transfer to."
    },
    {
      name: "_ids",
      type: "uint256[]",
      description: "The token types to transfer."
    },
    {
      name: "_values",
      type: "uint256[]",
      description: "The amounts of tokens to transfer for each type."
    },
    {
      name: "_operator",
      type: "address",
      description: "The address initiating the transfer (may be owner or approved operator)."
    }
  ]}
  showRequired={false}
/>

---
### safeTransferFrom

Safely transfers a single token type from one address to another. Validates ownership, approval, and receiver address before updating balances. Performs ERC1155Receiver validation if recipient is a contract (safe transfer). Complies with EIP-1155 safe transfer requirements.

<ExpandableCode language="solidity" maxLines={8}>
{`function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, address _operator) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The address to transfer from."
    },
    {
      name: "_to",
      type: "address",
      description: "The address to transfer to."
    },
    {
      name: "_id",
      type: "uint256",
      description: "The token type to transfer."
    },
    {
      name: "_value",
      type: "uint256",
      description: "The amount of tokens to transfer."
    },
    {
      name: "_operator",
      type: "address",
      description: "The address initiating the transfer (may be owner or approved operator)."
    }
  ]}
  showRequired={false}
/>

---
### setBaseURI

Sets the base URI prefix for token-specific URIs. The base URI is concatenated with token-specific URIs set via setTokenURI. Does not affect the default URI used when no token-specific URI is set.

<ExpandableCode language="solidity" maxLines={8}>
{`function setBaseURI(string memory _baseURI) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_baseURI",
      type: "string",
      description: "The base URI string to prepend to token-specific URIs."
    }
  ]}
  showRequired={false}
/>

---
### setTokenURI

Sets the token-specific URI for a given token ID. Sets tokenURIs[_tokenId] to the provided string and emits a URI event with the full computed URI. The emitted URI is the concatenation of baseURI and the token-specific URI.

<ExpandableCode language="solidity" maxLines={8}>
{`function setTokenURI(uint256 _tokenId, string memory _tokenURI) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The token ID to set the URI for."
    },
    {
      name: "_tokenURI",
      type: "string",
      description: "The token-specific URI string to be concatenated with baseURI."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="TransferBatch" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when multiple token types are transferred.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event TransferBatch(
address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values
);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_operator",
            type: "address",
            description: "The address which initiated the batch transfer."
          },
          {
            name: "_from",
            type: "address",
            description: "The address which previously owned the tokens."
          },
          {
            name: "_to",
            type: "address",
            description: "The address which now owns the tokens."
          },
          {
            name: "_ids",
            type: "uint256[]",
            description: "The token types being transferred."
          },
          {
            name: "_values",
            type: "uint256[]",
            description: "The amounts of tokens transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
  <Accordion title="TransferSingle" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when a single token type is transferred.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event TransferSingle(
address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value
);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_operator",
            type: "address",
            description: "The address which initiated the transfer."
          },
          {
            name: "_from",
            type: "address",
            description: "The address which previously owned the token."
          },
          {
            name: "_to",
            type: "address",
            description: "The address which now owns the token."
          },
          {
            name: "_id",
            type: "uint256",
            description: "The token type being transferred."
          },
          {
            name: "_value",
            type: "uint256",
            description: "The amount of tokens transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
  <Accordion title="URI" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when the URI for token type `_id` changes to `_value`.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event URI(string _value, uint256 indexed _id);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_value",
            type: "string",
            description: "The new URI for the token type."
          },
          {
            name: "_id",
            type: "uint256",
            description: "The token type whose URI changed."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC1155InsufficientBalance" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      **Title:** LibERC1155 â€” ERC-1155 Library Provides internal functions and storage layout for ERC-1155 multi-token logic. Thrown when insufficient balance for a transfer or burn operation. Uses ERC-8042 for storage location standardization and ERC-6093 for error conventions. This library is intended to be used by custom facets to integrate with ERC-1155 functionality.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC1155InsufficientBalance(address _sender, uint256 _balance, uint256 _needed, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC1155InvalidArrayLength" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when array lengths don't match in batch operations.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC1155InvalidArrayLength(uint256 _idsLength, uint256 _valuesLength);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC1155InvalidReceiver" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the receiver address is invalid.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC1155InvalidReceiver(address _receiver);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC1155InvalidSender" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the sender address is invalid.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC1155InvalidSender(address _sender);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC1155MissingApprovalForAll" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when missing approval for an operator.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC1155MissingApprovalForAll(address _operator, address _owner);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IERC1155Receiver} from "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";
import {ERC1155Mod} from "@compose/token/ERC1155/ERC1155Mod";
import {IDiamondReadable} from "@compose/diamond/IDiamondReadable.sol";

contract MyFacet is IDiamondReadable {
    address diamondAddress;

    constructor(address _diamondAddress) {
        diamondAddress = _diamondAddress;
    }

    function mintMyTokens(address _to, uint256 _id, uint256 _value) external {
        ERC1155Mod mod = ERC1155Mod(diamondAddress);
        mod.mint(_to, _id, _value);
    }

    function transferMyTokens(address _from, address _to, uint256 _id, uint256 _value) external {
        ERC1155Mod mod = ERC1155Mod(diamondAddress);
        // Assuming operator approval is handled elsewhere or is the caller
        mod.safeTransferFrom(_from, _to, _id, _value, msg.sender);
    }

    function getTokenURI(uint256 _tokenId) external view returns (string memory) {
        ERC1155Mod mod = ERC1155Mod(diamondAddress);
        // Accessing storage directly for URI is not exposed via function,
        // but you can infer it from the setTokenURI function's behavior.
        // For actual retrieval, a getter function would be needed in the facet.
        // This example demonstrates calling other module functions.
        string memory base = mod.getStorage().baseURI;
        string memory tokenSpecific = mod.getStorage().uri; // This is incorrect, uri is not mapped by tokenId
        // To properly get URI, a dedicated getter function in the module or facet is required.
        // This is a placeholder to show interaction.
        return ""; // Placeholder
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure proper access control is implemented in facets calling mint/burn functions.
- Always check for ERC1155InsufficientBalance errors when performing transfers or burns.
- When setting URIs, be aware that `setTokenURI` overrides the base URI for specific tokens.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
This module utilizes the Compose diamond storage pattern. It stores its state in a dedicated slot identified by `keccak256("compose.erc1155")`. Facets can access this storage via the `getStorage()` function, which returns an `ERC1155Storage` struct. The key fields within this struct are `uri` and `baseURI`. The `uri` field stores token-specific URIs, while `baseURI` stores the base URI prefix. Ensure this module is deployed and its storage slot is correctly initialized before interacting with its functions.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <RelatedDocs
    items={[
      {
        title: "ERC20PermitMod",
        href: "/docs/library/token/ERC20/ERC20Permit/ERC20PermitMod",
        description: "Related module in token",
        icon: "ðŸ“¦"
      },
      {
        title: "ERC20Mod",
        href: "/docs/library/token/ERC20/ERC20/ERC20Mod",
        description: "Related module in token",
        icon: "ðŸ“¦"
      },
      {
        title: "ERC20BridgeableMod",
        href: "/docs/library/token/ERC20/ERC20Bridgeable/ERC20BridgeableMod",
        description: "Related module in token",
        icon: "ðŸ“¦"
      }
    ]}
  />
</div>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC1155Mod" />
</div>

<LastUpdated date="2025-12-30T17:10:07.908Z" />
