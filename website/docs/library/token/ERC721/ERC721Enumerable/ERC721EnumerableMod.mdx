---
sidebar_position: 1
title: "ERC721EnumerableMod"
description: "Manage ERC-721 tokens with enumeration logic"
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/token/ERC721/ERC721Enumerable/ERC721EnumerableMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Manage ERC-721 tokens with enumeration logic
</DocSubtitle>

<Callout type="info" title="Key Features">
- Provides internal functions for ERC-721 minting, burning, and transfers.
- Maintains token enumeration order within diamond storage.
- Uses the diamond storage pattern at a predefined slot (`STORAGE_POSITION`).
- Functions are `internal` and designed for use within custom facets.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

This module provides internal functions for minting, burning, and transferring ERC-721 tokens while maintaining enumeration order. Facets import this module to implement standard ERC-721 enumerable behavior using shared diamond storage. Changes made through this module are immediately visible to all facets accessing the same storage.

---

## Storage

### ERC721EnumerableStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721EnumerableStorage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256[] ownerTokens) ownerTokens;
    mapping(uint256 tokenId => uint256 ownerTokensIndex) ownerTokensIndex;
    uint256[] allTokens;
    mapping(uint256 tokenId => uint256 allTokensIndex) allTokensIndex;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
    string name;
    string symbol;
    string baseURI;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.erc721.enumerable\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### burn

Burns (destroys) an existing ERC-721 token, removing it from enumeration lists. Reverts if the token does not exist or if the sender is not authorized.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _tokenId, address _sender) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to burn."
    },
    {
      name: "_sender",
      type: "address",
      description: "The address initiating the burn."
    }
  ]}
  showRequired={false}
/>

---
### getStorage

Returns the ERC-721 enumerable storage struct from its predefined slot. Uses inline assembly to point to the correct diamond storage position.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() pure returns (ERC721EnumerableStorage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC721EnumerableStorage",
      description: "The storage reference for ERC-721 enumerable state variables."
    }
  ]}
  showRequired={false}
/>

---
### mint

Mints a new ERC-721 token to the specified address, adding it to enumeration lists. Reverts if the receiver address is zero or if the token already exists.

<ExpandableCode language="solidity" maxLines={8}>
{`function mint(address _to, uint256 _tokenId) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_to",
      type: "address",
      description: "The address that will own the newly minted token."
    },
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to mint."
    }
  ]}
  showRequired={false}
/>

---
### transferFrom

Transfers a token ID from one address to another, updating enumeration data. Validates ownership, approval, and receiver address before state updates.

<ExpandableCode language="solidity" maxLines={8}>
{`function transferFrom(address _from, address _to, uint256 _tokenId, address _sender) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The current owner of the token."
    },
    {
      name: "_to",
      type: "address",
      description: "The address receiving the token."
    },
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token being transferred."
    },
    {
      name: "_sender",
      type: "address",
      description: "The initiator of the transfer (may be owner or approved operator)."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when ownership of a token changes, including minting and burning.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "The address transferring the token, or zero for minting."
          },
          {
            name: "_to",
            type: "address",
            description: "The address receiving the token, or zero for burning."
          },
          {
            name: "_tokenId",
            type: "uint256",
            description: "The ID of the token being transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721IncorrectOwner" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the sender is not the owner of the token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721IncorrectOwner(address _sender, uint256 _tokenId, address _owner);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when an operator lacks approval to manage a token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InvalidReceiver" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the receiver address is invalid.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InvalidReceiver(address _receiver);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InvalidSender" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the sender address is invalid.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InvalidSender(address _sender);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when attempting to interact with a non-existent token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

<!-- Usage Example section commented out for now -->
<!--
## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity >=0.8.30;
import @compose/token/ERC721/ERC721Enumerable/ERC721EnumerableMod;

contract ERC721EnumerableFacet {
    ERC721EnumerableMod private immutable _erc721EnumerableMod;

    constructor(address _moduleAddress) {
        _erc721EnumerableMod = ERC721EnumerableMod(_moduleAddress);
    }

    /**
     * @notice Mints a new ERC-721 token.
     * @param _to The address to mint the token to.
     * @param _tokenId The ID of the token to mint.
     */
    function mintToken(address _to, uint256 _tokenId) external {
        _erc721EnumerableMod.mint(_to, _tokenId);
    }

    /**
     * @notice Transfers an ERC-721 token.
     * @param _from The current owner of the token.
     * @param _to The new owner of the token.
     * @param _tokenId The ID of the token to transfer.
     */
    function transferTokenFrom(address _from, address _to, uint256 _tokenId) external {
        // Assuming \`msg.sender\` is the authorized caller for transfer
        _erc721EnumerableMod.transferFrom(_from, _to, _tokenId, msg.sender);
    }

    /**
     * @notice Burns an ERC-721 token.
     * @param _tokenId The ID of the token to burn.
     */
    function burnToken(uint256 _tokenId) external {
        // Assuming \`msg.sender\` is the owner or authorized to burn
        _erc721EnumerableMod.burn(_tokenId, msg.sender);
    }
}`}
</ExpandableCode>
-->

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure `msg.sender` or an approved address is passed correctly to `transferFrom` and `burn`.
- Handle potential errors like `ERC721NonexistentToken`, `ERC721IncorrectOwner`, and `ERC721InvalidReceiver`.
- Verify that the `_to` address in `mint` is not the zero address.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
This module utilizes the diamond storage pattern, accessing its state at the slot identified by `keccak256(\"compose.erc721.enumerable\")`. All state modifications, such as minting or burning, are written directly to this shared storage location. Consequently, any facet that imports and interacts with the same storage slot will observe these changes immediately, ensuring consistent state across the diamond.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <RelatedDocs
    items={[
      {
        title: "ERC20PermitMod",
        href: "/docs/library/token/ERC20/ERC20Permit/ERC20PermitMod",
        description: "Related module in token",
        icon: "ðŸ“¦"
      },
      {
        title: "ERC20Mod",
        href: "/docs/library/token/ERC20/ERC20/ERC20Mod",
        description: "Related module in token",
        icon: "ðŸ“¦"
      },
      {
        title: "ERC20BridgeableMod",
        href: "/docs/library/token/ERC20/ERC20Bridgeable/ERC20BridgeableMod",
        description: "Related module in token",
        icon: "ðŸ“¦"
      },
      {
        title: "ERC1155Mod",
        href: "/docs/library/token/ERC1155/ERC1155Mod",
        description: "Related module in token",
        icon: "ðŸ“¦"
      }
    ]}
  />
</div>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721EnumerableMod" />
</div>

<LastUpdated date="2025-12-30T20:08:44.714Z" />
