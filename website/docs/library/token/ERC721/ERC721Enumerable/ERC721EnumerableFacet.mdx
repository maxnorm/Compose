---
sidebar_position: 99
title: "ERC721EnumerableFacet"
description: "Enumerable ERC-721 token functionality for diamonds."
gitSource: "https://github.com/maxnorm/Compose/blob/7e2dd824639f424be644c4ebbb3ca2508167329f/src/token/ERC721/ERC721Enumerable/ERC721EnumerableFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Enumerable ERC-721 token functionality for diamonds.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Full ERC-721 enumerable implementation.
- Efficient querying of token metadata, supply, and ownership.
- Supports standard ERC-721 transfer and approval functions.
</Callout>

## Overview

This facet provides the complete ERC-721 enumerable extension, enabling efficient querying of token supply, ownership, and balances. It integrates seamlessly into a Compose diamond, offering a robust standard for non-fungible token management.

---

## Storage

### ERC721EnumerableStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721EnumerableStorage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256[] ownerTokens) ownerTokens;
    mapping(uint256 tokenId => uint256 ownerTokensIndex) ownerTokensIndex;
    uint256[] allTokens;
    mapping(uint256 tokenId => uint256 allTokensIndex) allTokensIndex;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
    string name;
    string symbol;
    string baseURI;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: "Diamond storage slot position for this module"
    }
  ]}
  showRequired={false}
/>

## Functions

### getStorage

Returns the storage struct used by this facet.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() internal pure returns (ERC721EnumerableStorage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC721EnumerableStorage",
      description: "The ERC721Enumerable storage struct."
    }
  ]}
  showRequired={false}
/>

---
### name

Returns the name of the token collection.

<ExpandableCode language="solidity" maxLines={8}>
{`function name() external view returns (string memory);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "string",
      description: "The token collection name."
    }
  ]}
  showRequired={false}
/>

---
### symbol

Returns the symbol of the token collection.

<ExpandableCode language="solidity" maxLines={8}>
{`function symbol() external view returns (string memory);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "string",
      description: "The token symbol."
    }
  ]}
  showRequired={false}
/>

---
### tokenURI

Provide the metadata URI for a given token ID.

<ExpandableCode language="solidity" maxLines={8}>
{`function tokenURI(uint256 _tokenId) external view returns (string memory);`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "tokenID of the NFT to query the metadata from"
    }
  ]}
  showRequired={false}
/>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "string",
      description: "the URI providing the detailed metadata of the specified tokenID"
    }
  ]}
  showRequired={false}
/>

---
### totalSupply

Returns the total number of tokens in existence.

<ExpandableCode language="solidity" maxLines={8}>
{`function totalSupply() external view returns (uint256);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "uint256",
      description: "The total supply of tokens."
    }
  ]}
  showRequired={false}
/>

---
### balanceOf

Returns the number of tokens owned by an address.

<ExpandableCode language="solidity" maxLines={8}>
{`function balanceOf(address _owner) external view returns (uint256);`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_owner",
      type: "address",
      description: "The address to query."
    }
  ]}
  showRequired={false}
/>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "uint256",
      description: "The balance (number of tokens owned)."
    }
  ]}
  showRequired={false}
/>

---
### ownerOf

Returns the owner of a given token ID.

<ExpandableCode language="solidity" maxLines={8}>
{`function ownerOf(uint256 _tokenId) public view returns (address);`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The token ID to query."
    }
  ]}
  showRequired={false}
/>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "address",
      description: "The address of the token owner."
    }
  ]}
  showRequired={false}
/>

---
### tokenOfOwnerByIndex

Returns a token ID owned by a given address at a specific index.

<ExpandableCode language="solidity" maxLines={8}>
{`function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_owner",
      type: "address",
      description: "The address to query."
    },
    {
      name: "_index",
      type: "uint256",
      description: "The index of the token."
    }
  ]}
  showRequired={false}
/>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "uint256",
      description: "The token ID owned by &#x60;_owner&#x60; at &#x60;_index&#x60;."
    }
  ]}
  showRequired={false}
/>

---
### getApproved

Returns the approved address for a given token ID.

<ExpandableCode language="solidity" maxLines={8}>
{`function getApproved(uint256 _tokenId) external view returns (address);`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The token ID to query."
    }
  ]}
  showRequired={false}
/>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "address",
      description: "The approved address for the token."
    }
  ]}
  showRequired={false}
/>

---
### isApprovedForAll

Returns whether an operator is approved for all tokens of an owner.

<ExpandableCode language="solidity" maxLines={8}>
{`function isApprovedForAll(address _owner, address _operator) external view returns (bool);`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_owner",
      type: "address",
      description: "The token owner."
    },
    {
      name: "_operator",
      type: "address",
      description: "The operator address."
    }
  ]}
  showRequired={false}
/>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "bool",
      description: "True if approved for all, false otherwise."
    }
  ]}
  showRequired={false}
/>

---
### approve

Approves another address to transfer a specific token ID.

<ExpandableCode language="solidity" maxLines={8}>
{`function approve(address _to, uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_to",
      type: "address",
      description: "The address being approved."
    },
    {
      name: "_tokenId",
      type: "uint256",
      description: "The token ID to approve."
    }
  ]}
  showRequired={false}
/>

---
### setApprovalForAll

Approves or revokes an operator to manage all tokens of the caller.

<ExpandableCode language="solidity" maxLines={8}>
{`function setApprovalForAll(address _operator, bool _approved) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_operator",
      type: "address",
      description: "The operator address."
    },
    {
      name: "_approved",
      type: "bool",
      description: "True to approve, false to revoke."
    }
  ]}
  showRequired={false}
/>

---
### internalTransferFrom

Internal function to transfer ownership of a token ID.

<ExpandableCode language="solidity" maxLines={8}>
{`function internalTransferFrom(address _from, address _to, uint256 _tokenId) internal;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The address sending the token."
    },
    {
      name: "_to",
      type: "address",
      description: "The address receiving the token."
    },
    {
      name: "_tokenId",
      type: "uint256",
      description: "The token ID being transferred."
    }
  ]}
  showRequired={false}
/>

---
### transferFrom

Transfers a token from one address to another.

<ExpandableCode language="solidity" maxLines={8}>
{`function transferFrom(address _from, address _to, uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The current owner of the token."
    },
    {
      name: "_to",
      type: "address",
      description: "The recipient address."
    },
    {
      name: "_tokenId",
      type: "uint256",
      description: "The token ID to transfer."
    }
  ]}
  showRequired={false}
/>

---
### safeTransferFrom

Safely transfers a token, checking for receiver contract compatibility.

<ExpandableCode language="solidity" maxLines={8}>
{`function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The current owner of the token."
    },
    {
      name: "_to",
      type: "address",
      description: "The recipient address."
    },
    {
      name: "_tokenId",
      type: "uint256",
      description: "The token ID to transfer."
    }
  ]}
  showRequired={false}
/>

---
### safeTransferFrom

Safely transfers a token with additional data.

<ExpandableCode language="solidity" maxLines={8}>
{`function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_from",
      type: "address",
      description: "The current owner of the token."
    },
    {
      name: "_to",
      type: "address",
      description: "The recipient address."
    },
    {
      name: "_tokenId",
      type: "uint256",
      description: "The token ID to transfer."
    },
    {
      name: "_data",
      type: "bytes",
      description: "Additional data to send to the receiver contract."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

  </Accordion>
  <Accordion title="Approval" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Approval(address indexed _owner, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

  </Accordion>
  <Accordion title="ApprovalForAll" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);`}
      </ExpandableCode>
    </div>

  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721InvalidOwner" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InvalidOwner(address _owner);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721IncorrectOwner" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721IncorrectOwner(address _sender, uint256 _tokenId, address _owner);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InvalidSender" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InvalidSender(address _sender);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InvalidReceiver" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InvalidReceiver(address _receiver);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InvalidApprover" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InvalidApprover(address _approver);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InvalidOperator" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InvalidOperator(address _operator);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721OutOfBoundsIndex" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721OutOfBoundsIndex(address _owner, uint256 _index);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IERC721EnumerableFacet} from "@compose-protocol/diamond/facets/ERC721/IERC721EnumerableFacet.sol";

contract MyDiamondConsumer {
    address immutable diamondAddress;

    constructor(address _diamondAddress) {
        diamondAddress = _diamondAddress;
    }

    function getTotalSupply() external view returns (uint256) {
        // Selector for totalSupply function
        bytes4 selector = IERC721EnumerableFacet.totalSupply.selector;
        (bool success, bytes memory data) = diamondAddress.staticcall(abi.encodeWithSelector(selector));
        require(success, "Call failed");
        return abi.decode(data, (uint256));
    }

    function getOwnerOfToken(uint256 _tokenId) external view returns (address) {
        // Selector for ownerOf function
        bytes4 selector = IERC721EnumerableFacet.ownerOf.selector;
        (bool success, bytes memory data) = diamondAddress.staticcall(abi.encodeWithSelector(selector, _tokenId));
        require(success, "Call failed");
        return abi.decode(data, (address));
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Initialize the facet with a unique storage slot to prevent state collisions.
- Use the `internalTransferFrom` function only within trusted internal contract logic to maintain ownership integrity.
- Ensure the diamond's access control mechanisms correctly gate administrative functions like approvals.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
Access control for `approve` and `setApprovalForAll` must be handled by the diamond's meta-contract. Ensure `internalTransferFrom` is not exposed externally. Input validation for token IDs and addresses is crucial to prevent errors and potential exploits. Be mindful of gas costs for enumerable operations on very large token supplies.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721EnumerableFacet" />
</div>

<LastUpdated date="2025-12-21T21:54:45.113Z" />
